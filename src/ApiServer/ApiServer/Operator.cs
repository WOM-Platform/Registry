using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;
using MongoDB.Bson;
using MongoDB.Driver.GeoJsonObjectModel;
using WomPlatform.Connector.Models;
using WomPlatform.Web.Api.DatabaseDocumentModels;

namespace WomPlatform.Web.Api {

    /// <summary>
    /// Encloses common voucher operations.
    /// </summary>
    public class Operator {

        private readonly MongoDatabase Mongo;
        private readonly DataContext Database;
        private readonly IConfiguration Configuration;
        private readonly ILogger<Operator> Logger;

        private readonly Random Random = new Random();

        private readonly int DefaultAutogeneratedPasswordLength;
        private readonly int DefaultSecretLength;

        public Operator(
            MongoDatabase mongo,
            DataContext database,
            IConfiguration configuration,
            ILogger<Operator> logger
        ) {
            Mongo = mongo;
            Database = database;
            Configuration = configuration;
            Logger = logger;

            var confSection = Configuration.GetSection("PasswordSecurity");
            DefaultAutogeneratedPasswordLength = Convert.ToInt32(confSection["AutogeneratedLength"]);
            DefaultSecretLength = Convert.ToInt32(confSection["SecretLength"]);
        }

        private byte[] GenerateSecret() {
            byte[] buffer = new byte[DefaultSecretLength];
            Random.NextBytes(buffer);
            return buffer;
        }

        /// <summary>
        /// Creates a new voucher generation instance.
        /// </summary>
        public async Task<(Guid Otc, string Password)> CreateGenerationRequest(
            Source source,
            VoucherCreatePayload.Content creationParameters,
            bool isPreVerified = false
        ) {
            if(!creationParameters.SourceId.Equals(source.Id.ToString())) {
                throw new ArgumentException($"Incoherent POS IDs {creationParameters.SourceId} != {source.Id}");
            }

            // TODO: validate whether source is allowed to generate vouchers (check aims)

            var otc = Guid.NewGuid();
            var password = creationParameters.Password ?? Random.GeneratePassword(DefaultAutogeneratedPasswordLength);

            var genRequest = new GenerationRequest {
                Otc = otc,
                Amount = creationParameters.Vouchers.Length,
                TotalVoucherCount = (from v in creationParameters.Vouchers select v.Count).Sum(),
                CreatedAt = DateTime.UtcNow,
                Verified = isPreVerified,
                SourceId = source.Id,
                Nonce = creationParameters.Nonce,
                Password = password
            };
            await Mongo.AddGenerationRequest(genRequest);
            Logger.LogDebug("Generation request {0} persisted", otc);

            var vouchers = from v in creationParameters.Vouchers
                           let secret = GenerateSecret()
                           select new Voucher {
                               Secret = secret.ToBase64(),
                               AimCode = v.Aim,
                               Position = GeoJson.Point(GeoJson.Geographic(v.Longitude, v.Latitude)),
                               Timestamp = v.Timestamp,
                               Count = v.Count,
                               InitialCount = v.Count,
                               GenerationRequestId = otc
                           };
            await Mongo.AddVouchers(vouchers);
            Logger.LogDebug("{0} voucher documents stored for request {1}", vouchers.Count(), otc);

            return (otc, password);
        }

        /// <summary>
        /// Verifies a voucher generation request.
        /// </summary>
        public async Task VerifyGenerationRequest(Guid otcGen) {
            var request = await Mongo.GetGenerationRequestByOtc(otcGen);
            if(request == null) {
                throw new ArgumentException("OTC code not valid");
            }

            if(!request.Verified) {
                request.Verified = true;
                await Mongo.UpdateGenerationRequest(request);
            }
        }

        /// <summary>
        /// Redeems vouchers tied to a given OTC_gen code and marks
        /// the generation request instance as completed.
        /// </summary>
        public async Task<(Source Source, IEnumerable<Voucher> Vouchers)> GenerateVouchers(Guid otcGen, string password) {
            var request = await Mongo.GetGenerationRequestByOtc(otcGen);

            if(request == null) {
                throw new ArgumentException("OTC code not valid");
            }
            if(!request.Verified) {
                throw new ArgumentException("OTC code not verified");
            }
            if(request.PerformedAt.HasValue) {
                throw new InvalidOperationException("Vouchers already redeemed");
            }
            if(request.Void) {
                throw new InvalidOperationException("Voucher generation request has been voided");
            }
            if(!request.Password.Equals(password, StringComparison.Ordinal)) {
                request.Void = true;
                await Mongo.UpdateGenerationRequest(request);

                throw new ArgumentException("Password does not match, request has been voided");
            }

            request.PerformedAt = DateTime.UtcNow;
            await Mongo.UpdateGenerationRequest(request);

            var source = await Mongo.GetSourceById(request.SourceId);
            var vouchers = await Mongo.GetVouchersByGenerationRequest(otcGen);

            return (source, vouchers);
        }

        /// <summary>
        /// Creates a new voucher generation instance.
        /// </summary>
        public async Task<(Guid Otc, string Password)> CreatePaymentRequest(
            Pos pointOfService,
            PaymentRegisterPayload.Content creationParameters,
            bool isPreVerified = false
        ) {
            if(!creationParameters.PosId.Equals(pointOfService.Id.ToString())) {
                throw new ArgumentException("Incoherent POS IDs");
            }

            var otc = Guid.NewGuid();
            var password = creationParameters.Password ?? Random.GeneratePassword(DefaultAutogeneratedPasswordLength);

            var payRequest = new PaymentRequest {
                Otc = otc,
                Amount = creationParameters.Amount,
                CreatedAt = DateTime.UtcNow,
                Verified = isPreVerified,
                IsPersistent = creationParameters.Persistent,
                PosId = pointOfService.Id,
                Nonce = creationParameters.Nonce,
                Password = password,
                AckUrlPocket = creationParameters.PocketAckUrl,
                AckUrlPos = creationParameters.PosAckUrl
            };
            if(creationParameters.SimpleFilter != null) {
                payRequest.Filter = new Filter {
                    Aims = creationParameters.SimpleFilter.Aim,
                    Bounds = creationParameters.SimpleFilter.GetBounds(),
                    MaxAge = creationParameters.SimpleFilter.MaxAge
                };
            }
            await Mongo.AddPaymentRequest(payRequest);

            return (otc, password);
        }

        /// <summary>
        /// Verifies a payment creation request.
        /// </summary>
        public async Task VerifyPaymentRequest(Guid otcPay) {
            var request = await Mongo.GetPaymentRequestByOtc(otcPay);
            if(request == null) {
                throw new ArgumentException("OTC code not valid");
            }

            if(!request.Verified) {
                request.Verified = true;
                await Mongo.UpdatePaymentRequest(request);
            }
        }

        /// <summary>
        /// Verifies single vouchers, checks filter satisfaction, and reduces count.
        /// </summary>
        private bool UpdateAndVerifyVouchers(
            PaymentConfirmPayload.VoucherInfo vi,
            IDictionary<ObjectId, Voucher> voucherMap,
            Filter filter
        ) {
            var objId = new ObjectId(vi.Id.GetBaseId());
            if(!voucherMap.ContainsKey(objId)) {
                Logger.LogError(LoggingEvents.Operations, "Looking for voucher {0} in Mongo vouchers, not found", vi.Id);
                return false;
            }

            var voucher = voucherMap[objId];
            if(!voucher.Secret.Equals(vi.Secret, StringComparison.InvariantCulture)) {
                Logger.LogInformation(LoggingEvents.Operations, "Secret for voucher {0} does not match", vi.Id);
                return false;
            }

            // Match filter
            if(filter?.Aims == null && voucher.AimCode.StartsWith("0")) {
                // No aim filter, but voucher is a "demo" voucher
                Logger.LogInformation(LoggingEvents.Operations, "Voucher {0} matches 0 demo aim filter", vi.Id);
                return false;
            }
            if(filter?.Aims != null && !voucher.AimCode.StartsWith(filter.Aims)) {
                // Voucher does not match aim filter
                Logger.LogInformation(LoggingEvents.Operations, "Voucher {0} does not match aim filter '{1}'", vi.Id, filter.Aims);
                return false;
            }
            if(filter?.Bounds != null && !filter.Bounds.Contains(voucher.Position.Coordinates)) {
                // Voucher not contained in geographical bounds
                Logger.LogInformation(LoggingEvents.Operations, "Voucher {0} is outside geographical bounds", vi.Id);
                return false;
            }
            if(filter?.MaxAge != null && DateTime.UtcNow.Subtract(voucher.Timestamp) > TimeSpan.FromSeconds(filter.MaxAge.Value)) {
                // Voucher too old
                Logger.LogInformation(LoggingEvents.Operations, "Voucher {0} is older than {1} days (age {2})", vi.Id, filter.MaxAge.Value, DateTime.UtcNow.Subtract(voucher.Timestamp));
                return false;
            }

            // Update voucher count for update
            if(voucher.Count <= 0) {
                Logger.LogInformation(LoggingEvents.Operations, "Voucher {0} already spent", vi.Id);
                return false;
            }
            voucher.Count -= 1;

            return true;
        }

        private async Task<int> ProcessPaymentNewVouchers(IEnumerable<PaymentConfirmPayload.VoucherInfo> v, Filter filter) {
            // Extract distinct base IDs
            var newVoucherIds = v.Select(v => v.Id.GetBaseId()).Distinct().Select(s => new ObjectId(s));

            // Retrieve distinct voucher instances from Mongo
            var mongoVouchers = (await Mongo.GetVouchersWithIds(newVoucherIds)).ToDictionary(v => v.Id);
            if(newVoucherIds.Count() != mongoVouchers.Count) {
                // One or more distinct IDs did not load
                Logger.LogError(LoggingEvents.Operations, "One or more vouchers does not exist ({0} expected, {1} found in DB)", newVoucherIds.Count(), mongoVouchers.Count);
                throw new ArgumentException("One or more voucher(s) not found");
            }

            if(!v.All(v => UpdateAndVerifyVouchers(v, mongoVouchers, filter))) {
                Logger.LogError(LoggingEvents.Operations, "One or more vouchers did not satisfy constraints");
                throw new ArgumentException("Invalid voucher(s)");
            }

            await Mongo.ReplaceVouchers(mongoVouchers.Values);

            return v.Count();
        }

        private async Task<int> ProcessPaymentOldVouchers(IEnumerable<PaymentConfirmPayload.VoucherInfo> vi, Filter filter) {
            var voucherIds = vi.Select(v => v.Id.ToLong()).ToArray();
            var vouchers = (from v in Database.Vouchers
                            where voucherIds.Contains(v.Id)
                            where !v.Spent
                            select v);
            var voucherMap = vouchers.ToDictionary(v => v.Id);

            var validCount = vi.Count(vi => {
                var suppliedId = vi.Id.ToLong();
                if(!voucherMap.ContainsKey(suppliedId)) {
                    Logger.LogInformation(LoggingEvents.Operations, "Voucher {0} spent or not existing", vi.Id);
                    return false;
                }

                var expectedSecret = voucherMap[suppliedId].Secret.ToBase64();
                if(!vi.Secret.Equals(expectedSecret, StringComparison.InvariantCulture)) {
                    Logger.LogInformation(LoggingEvents.Operations, "Secret of voucher {0} not valid (is '{1}', expedted '{2}')", vi.Id, vi.Secret, expectedSecret);
                    return false;
                }

                // We trust client-side validation for old vouchers 🤞

                return true;
            });

            foreach(var v in vouchers) {
                v.Spent = true;
            }
            await Database.SaveChangesAsync();

            return validCount;
        }

        public async Task<PaymentRequest> ProcessPayment(PaymentConfirmPayload.Content request) {
            var payment = await Mongo.GetPaymentRequestByOtc(request.Otc);
            if(payment == null) {
                Logger.LogInformation(LoggingEvents.Operations, "Payment {0} not found", request.Otc);
                throw new ArgumentException("OTC code not valid");
            }
            if(!payment.Verified) {
                Logger.LogInformation(LoggingEvents.Operations, "Payment {0} not verified, cannot be performed", request.Otc);
                throw new ArgumentException("OTC code not verified");
            }
            if(!payment.IsPersistent && payment.Confirmations?.Count > 0) {
                Logger.LogInformation(LoggingEvents.Operations, "Payment {0} not persistent and already performed");
                throw new InvalidOperationException("Payment already performed");
            }
            if(!payment.Password.Equals(request.Password, StringComparison.Ordinal)) {
                Logger.LogInformation(LoggingEvents.Operations, "Payment password does not match");
                throw new ArgumentException("Password does not match");
            }
            if(request.Vouchers.Length != payment.Amount) {
                Logger.LogInformation(LoggingEvents.Operations, "{0} vouchers given instead of {1}", request.Vouchers.Length, payment.Amount);
                throw new ArgumentException("Wrong number of vouchers");
            }

            int oldCount = await ProcessPaymentOldVouchers(request.Vouchers.Where(v => !v.Id.ToString().Contains('/')), payment.Filter);
            int newCount = await ProcessPaymentNewVouchers(request.Vouchers.Where(v => v.Id.Id.Contains('/')), payment.Filter);
            Logger.LogDebug("Old vouchers spent {0}, new vouchers spent {1}", oldCount, newCount);
            if(oldCount + newCount < payment.Amount) {
                Logger.LogInformation(LoggingEvents.Operations, "Found {0} valid vouchers, less than requested ({1})", newCount + oldCount, payment.Amount);
                throw new ArgumentException("Insufficient number of valid vouchers");
            }

            Logger.LogDebug(LoggingEvents.Operations, "Payment confirmed, vouchers updated");

            if(payment.Confirmations == null) {
                payment.Confirmations = new List<PaymentConfirmation>();
            }
            payment.Confirmations.Add(new PaymentConfirmation {
                PerformedAt = DateTime.UtcNow
            });
            await Mongo.UpdatePaymentRequest(payment);

            Logger.LogDebug(LoggingEvents.Operations, "Payment confirmation stored");

            return payment;
        }

    }

}
