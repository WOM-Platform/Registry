using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;
using MongoDB.Bson;
using MongoDB.Driver;
using WomPlatform.Connector.Models;
using WomPlatform.Web.Api.DatabaseDocumentModels;
using WomPlatform.Web.Api.DTO;
using WomPlatform.Web.Api.Utilities;

namespace WomPlatform.Web.Api.Service {
    public class PaymentService : BaseService {
        private readonly int DefaultAutogeneratedPasswordLength;
        private readonly int DefaultSecretLength;
        private readonly int RequestInitialAttempts;

        public PaymentService(
            MongoClient client,
            IConfiguration configuration,
            ILogger<BackupService> logger
        ) : base(client, logger) {
            IConfigurationSection voucherSecuritySection = configuration.GetRequiredSection("Security").GetRequiredSection("Vouchers");
            DefaultAutogeneratedPasswordLength = Convert.ToInt32(voucherSecuritySection["AutogeneratedLength"]);
            DefaultSecretLength = Convert.ToInt32(voucherSecuritySection["SecretLength"]);
            RequestInitialAttempts = Convert.ToInt32(voucherSecuritySection["RequestInitialAttempts"]);
        }

        private Task<List<Voucher>> GetVouchersWithIds(IEnumerable<ObjectId> ids) {
            FilterDefinition<Voucher> filter = Builders<Voucher>.Filter.In(v => v.Id, ids);
            return VoucherCollection.Find(filter).ToListAsync();
        }

        private Task ReplaceVouchers(IEnumerable<Voucher> vouchers) {
            IEnumerable<ReplaceOneModel<Voucher>> replaces = from v in vouchers
                                                             let filter = Builders<Voucher>.Filter.Eq(vf => vf.Id, v.Id)
                                                             select new ReplaceOneModel<Voucher>(filter, v);
            return VoucherCollection.BulkWriteAsync(replaces);
        }

        private Task<List<LegacyVoucher>> GetLegacyVouchersWithIds(IEnumerable<long> ids) {
            FilterDefinition<LegacyVoucher> filter = Builders<LegacyVoucher>.Filter.In(v => v.Id, ids);
            return LegacyVoucherCollection.Find(filter).ToListAsync();
        }

        private Task ReplaceLegacyVouchers(IEnumerable<LegacyVoucher> vouchers) {
            IEnumerable<ReplaceOneModel<LegacyVoucher>> replaces = from v in vouchers
                                                                   let filter = Builders<LegacyVoucher>.Filter.Eq(vf => vf.Id, v.Id)
                                                                   select new ReplaceOneModel<LegacyVoucher>(filter, v);
            return LegacyVoucherCollection.BulkWriteAsync(replaces);
        }

        /// <summary>
        ///     Retrieves a list of all persistent payments.
        /// </summary>
        public Task<List<PaymentRequest>> GetPersistentPayments() {
            FilterDefinition<PaymentRequest> filter = Builders<PaymentRequest>.Filter.And(
                Builders<PaymentRequest>.Filter.Eq(pr => pr.Verified, true),
                Builders<PaymentRequest>.Filter.Eq(pr => pr.IsPersistent, true)
            );

            return PaymentRequestCollection.Find(filter).ToListAsync();
        }

        /// <summary>
        ///     Create a new payment request.
        /// </summary>
        /// <param name="pointOfService">Owning POS instance.</param>
        /// <param name="amount">Amount of WOM vouchers request for the payment.</param>
        /// <param name="filter">Filter that WOM vouchers must satisfy.</param>
        /// <param name="password">Optional user-set password.</param>
        /// <param name="nonce">Optional nonce value.</param>
        /// <param name="ackUrlPocket">Optional ack URL for the Pocket app.</param>
        /// <param name="ackUrlPos">Optional ack URL for the POS.</param>
        /// <param name="isPersistent">Whether the payment is persistent.</param>
        /// <param name="isPreVerified">Whether the payment is verified upon creation.</param>
        public async Task<PaymentRequest> CreatePaymentRequest(
            Pos pointOfService,
            int amount,
            Filter filter,
            string password = null,
            string nonce = null,
            string ackUrlPocket = null,
            string ackUrlPos = null,
            bool isPersistent = false,
            bool isPreVerified = false
        ) {
            if(pointOfService == null) {
                throw new ArgumentNullException(nameof(pointOfService));
            }

            Guid otc = Guid.NewGuid();
            password ??= Random.GenerateNumericCode(DefaultAutogeneratedPasswordLength);

            PaymentRequest payRequest = new PaymentRequest {
                Otc = otc,
                Amount = amount,
                Filter = filter,
                CreatedAt = DateTime.UtcNow,
                Verified = isPreVerified,
                IsPersistent = isPersistent,
                MerchantId = pointOfService.MerchantId,
                PosId = pointOfService.Id,
                Nonce = nonce ?? string.Concat(pointOfService.Id, Guid.NewGuid()),
                Password = password,
                AckUrlPocket = ackUrlPocket,
                AckUrlPos = ackUrlPos
            };
            await PaymentRequestCollection.InsertOneAsync(payRequest);

            return payRequest;
        }

        /// <summary>
        ///     Verifies a payment creation request.
        /// </summary>
        public async Task VerifyPaymentRequest(Guid otcPay) {
            UpdateResult results = await PaymentRequestCollection.UpdateOneAsync(
                Builders<PaymentRequest>.Filter.Eq(p => p.Otc, otcPay),
                Builders<PaymentRequest>.Update.Set(pr => pr.Verified, true)
            );

            if(results.MatchedCount != 1 || results.ModifiedCount != 1) {
                throw new Exception("Payment request does not exist or was already verified");
            }
        }

        public Task<PaymentRequest> GetPaymentRequestByOtc(Guid otcPay) {
            FilterDefinition<PaymentRequest> filter = Builders<PaymentRequest>.Filter.Eq(p => p.Otc, otcPay);
            return PaymentRequestCollection.Find(filter).SingleOrDefaultAsync();
        }

        public Task UpdatePaymentRequest(PaymentRequest request) {
            FilterDefinition<PaymentRequest> filter = Builders<PaymentRequest>.Filter.Eq(r => r.Otc, request.Otc);
            return PaymentRequestCollection.ReplaceOneAsync(filter, request);
        }

        /// <summary>
        ///     Verifies single vouchers, checks filter satisfaction, and reduces count.
        /// </summary>
        private bool UpdateAndVerifyVouchers(
            PaymentConfirmPayload.VoucherInfo vi,
            IDictionary<ObjectId, Voucher> voucherMap,
            Filter filter
        ) {
            ObjectId objId = new ObjectId(vi.Id.GetBaseId());
            if(!voucherMap.ContainsKey(objId)) {
                Logger.LogError(LoggingEvents.Operations, "Looking for voucher {0} in Mongo vouchers, not found", vi.Id);
                return false;
            }

            Voucher voucher = voucherMap[objId];
            if(!voucher.Secret.Equals(vi.Secret, StringComparison.InvariantCulture)) {
                Logger.LogInformation(LoggingEvents.Operations, "Secret for voucher {0} does not match", vi.Id);
                return false;
            }

            // Match filter
            if(filter?.Aims == null && voucher.AimCode.StartsWith("0")) {
                // No aim filter, but voucher is a "demo" voucher
                Logger.LogInformation(LoggingEvents.Operations, "Voucher {0} matches 0 demo aim filter", vi.Id);
                return false;
            }

            if(filter?.Aims != null && !voucher.AimCode.StartsWith(filter.Aims)) {
                // Voucher does not match aim filter
                Logger.LogInformation(LoggingEvents.Operations, "Voucher {0} does not match aim filter '{1}'", vi.Id, filter.Aims);
                return false;
            }

            if(filter?.Bounds != null && !filter.Bounds.Contains(voucher.Position.Coordinates)) {
                // Voucher not contained in geographical bounds
                Logger.LogInformation(LoggingEvents.Operations, "Voucher {0} is outside geographical bounds", vi.Id);
                return false;
            }

            if(filter?.MaxAge != null && DateTime.UtcNow.Subtract(voucher.Timestamp) > TimeSpan.FromDays(filter.MaxAge.Value)) {
                // Voucher too old
                Logger.LogInformation(LoggingEvents.Operations, "Voucher {0} is older than {1} days (age {2})",
                    vi.Id, filter.MaxAge.Value, DateTime.UtcNow.Subtract(voucher.Timestamp));
                return false;
            }

            // Update voucher count for update
            if(voucher.Count <= 0) {
                Logger.LogInformation(LoggingEvents.Operations, "Voucher {0} already spent", vi.Id);
                return false;
            }

            voucher.Count -= 1;

            return true;
        }

        private async Task<int> ProcessPaymentVouchers(IEnumerable<PaymentConfirmPayload.VoucherInfo> vi, Filter filter) {
            if(vi.Count() == 0) {
                return 0;
            }

            // Extract distinct base IDs
            IEnumerable<ObjectId> voucherIds = vi.Select(v => v.Id.GetBaseId()).Distinct().Select(s => new ObjectId(s));

            // Retrieve distinct voucher instances from Mongo
            Dictionary<ObjectId, Voucher> vouchers = (await GetVouchersWithIds(voucherIds)).ToDictionary(v => v.Id);
            if(voucherIds.Count() != vouchers.Count) {
                // One or more distinct IDs did not load
                Logger.LogError(LoggingEvents.Operations, "One or more vouchers does not exist ({0} expected, {1} found in DB)", voucherIds.Count(), vouchers.Count);
                throw new ArgumentException("One or more voucher(s) not found");
            }

            if(!vi.All(v => UpdateAndVerifyVouchers(v, vouchers, filter))) {
                Logger.LogError(LoggingEvents.Operations, "One or more vouchers did not satisfy constraints");
                throw new ArgumentException("Invalid voucher(s)");
            }

            // TODO: this must be done in a two-step process
            await ReplaceVouchers(vouchers.Values);

            return vi.Count();
        }

        private async Task<int> ProcessPaymentLegacyVouchers(IEnumerable<PaymentConfirmPayload.VoucherInfo> vi, Filter filter) {
            if(vi.Count() == 0) {
                return 0;
            }

            IEnumerable<long> voucherIds = vi.Select(v => v.Id.ToLong());

            Dictionary<long, LegacyVoucher> vouchers = (await GetLegacyVouchersWithIds(voucherIds)).ToDictionary(v => v.Id);
            if(voucherIds.Count() != vouchers.Count) {
                // One or more IDs did not load
                Logger.LogError(LoggingEvents.Operations,
                    "One or more V1 vouchers does not exist ({0} expected, {1} found in DB)", voucherIds.Count(),
                    vouchers.Count);
                throw new ArgumentException("One or more voucher(s) not found");
            }

            if(!vi.All(expected => {
                   if(!vouchers.ContainsKey(expected.Id.ToLong())) {
                       Logger.LogInformation(LoggingEvents.Operations, "Voucher {0} not found", expected.Id);
                       return false;
                   }

                   LegacyVoucher voucher = vouchers[expected.Id.ToLong()];

                   if(voucher.Spent) {
                       Logger.LogInformation(LoggingEvents.Operations, "Voucher {0} spent", voucher.Id);
                       return false;
                   }

                   if(!voucher.Secret.Equals(expected.Secret, StringComparison.InvariantCulture)) {
                       Logger.LogInformation(LoggingEvents.Operations, "Secret of voucher {0} not valid (is '{1}', expected '{2}')", voucher.Id, voucher.Secret, expected.Secret);
                       return false;
                   }

                   // Trust client-side validation for old vouchers 🤞

                   return true;
               })) {
                Logger.LogError(LoggingEvents.Operations, "One or more V1 vouchers did not satisfy constraints");
                throw new ArgumentException("Invalid voucher(s)");
            }

            // TODO: this must be done in a two-step process
            foreach(LegacyVoucher v in vouchers.Values) {
                v.Spent = true;
            }

            await ReplaceLegacyVouchers(vouchers.Values);

            return vouchers.Count;
        }

        public async Task<PaymentRequest> ProcessPayment(PaymentConfirmPayload.Content request) {
            PaymentRequest payment = await GetPaymentRequestByOtc(request.Otc);
            if(payment == null) {
                Logger.LogInformation(LoggingEvents.Operations, "Payment {0} not found", request.Otc);
                throw new ServiceProblemException(
                    "OTC code does not exist",
                    StatusCodes.Status404NotFound,
                    "https://wom.social/api/problems/otc-not-valid"
                );
            }

            if(!payment.Verified) {
                Logger.LogInformation(LoggingEvents.Operations, "Payment {0} not verified, cannot be performed", request.Otc);
                throw new ServiceProblemException(
                    "OTC code does not exist",
                    StatusCodes.Status404NotFound,
                    "https://wom.social/api/problems/otc-not-valid"
                );
            }

            if(!payment.IsPersistent && payment.Confirmations?.Count > 0) {
                Logger.LogInformation(LoggingEvents.Operations, "Payment {0} not persistent and already performed", request.Otc);
                throw new ServiceProblemException(
                    "Operation already performed",
                    StatusCodes.Status400BadRequest,
                    "https://wom.social/api/problems/operation-already-performed"
                );
            }

            if(!payment.Password.Equals(request.Password, StringComparison.Ordinal)) {
                Logger.LogInformation(LoggingEvents.Operations, "Payment password does not match");
                throw new ServiceProblemException(
                    "Wrong password",
                    StatusCodes.Status422UnprocessableEntity,
                    "https://wom.social/api/problems/wrong-password"
                );
            }

            if(request.Vouchers.Length != payment.Amount) {
                Logger.LogInformation(LoggingEvents.Operations, "{0} vouchers given instead of {1}", request.Vouchers.Length, payment.Amount);
                throw new ServiceProblemException(
                    "Wrong number of vouchers supplied",
                    StatusCodes.Status400BadRequest,
                    "https://wom.social/api/problems/wrong-number-of-vouchers",
                    "required", payment.Amount.ToString(),
                    "supplied", request.Vouchers.Length.ToString()
                );
            }

            int v1Count = await ProcessPaymentLegacyVouchers(request.Vouchers.Where(v => !v.Id.ToString().Contains('/')), payment.Filter);
            int v2Count = await ProcessPaymentVouchers(request.Vouchers.Where(v => v.Id.Id.Contains('/')), payment.Filter);
            Logger.LogDebug("V1 vouchers spent {0}, V2 vouchers spent {1}", v1Count, v2Count);
            if(v1Count + v2Count < payment.Amount) {
                Logger.LogInformation(LoggingEvents.Operations, "Found {0} valid vouchers, less than requested ({1})", v2Count + v1Count, payment.Amount);
                throw new ServiceProblemException(
                    "Insufficient valid vouchers supplied",
                    StatusCodes.Status400BadRequest,
                    "https://wom.social/api/problems/insufficient-valid-vouchers",
                    "required", payment.Amount.ToString(),
                    "supplied", (v2Count + v1Count).ToString()
                );
            }

            Logger.LogDebug(LoggingEvents.Operations, "Payment confirmed, vouchers updated");

            if(payment.Confirmations == null) {
                payment.Confirmations = [];
            }

            payment.Confirmations.Add(new PaymentConfirmation {
                PerformedAt = DateTime.UtcNow
            });
            await UpdatePaymentRequest(payment);

            Logger.LogDebug(LoggingEvents.Operations, "Payment confirmation stored");

            return payment;
        }

        /// <summary>
        ///     Marks vouchers as spent for a voucher transfer.
        /// </summary>
        public async Task<int> MarkVouchersForTransfer(VoucherTransferPayload.Content request) {
            int v1Count = await ProcessPaymentLegacyVouchers(request.Vouchers.Where(v => !v.Id.ToString().Contains('/')).Select(v => new PaymentConfirmPayload.VoucherInfo { Id = v.Id, Secret = v.Secret }), null);
            int v2Count = await ProcessPaymentVouchers(request.Vouchers.Where(v => v.Id.Id.Contains('/')).Select(v => new PaymentConfirmPayload.VoucherInfo { Id = v.Id, Secret = v.Secret }), null);
            Logger.LogDebug("V1 vouchers spent {0}, V2 vouchers spent {1}", v1Count, v2Count);

            return v1Count + v2Count;
        }


        public async Task<VoucherConsumptionStatsResponse> FetchTotalVouchersConsumedStats(
            DateTime? startDate,
            DateTime? endDate,
            ObjectId[] merchantId,
            bool isCsvRequest = false
        ) {
            VouchersConsumedDTO totalConsumed = await FetchTotalVouchersConsumed(null, null, merchantId);
            VouchersConsumedDTO totalEverConsumed = await FetchTotalVouchersConsumed(null, null, merchantId);
            List<TotalConsumedOverTimeDto> totalConsumedOverTimeDtos = await GetTotalConsumedVouchersOverTime(null, null, merchantId, isCsvRequest);
            List<MerchantRankDTO> merchantRankDtos = await GetMerchantRank(null, null, merchantId);
            return new VoucherConsumptionStatsResponse {
                ConsumedInPeriod = totalConsumed.TotalAmount,
                TransactionsInPeriod = totalConsumed.TransactionNumber,
                TotalTransactions = totalEverConsumed.TransactionNumber,
                TotalConsumed = totalEverConsumed.TotalAmount,
                MerchantRanks = merchantRankDtos,
                MerchantOvertimeRanks = null,
                TotalConsumedOverTime = totalConsumedOverTimeDtos
            };
            // if(isCsvRequest) {
            //     List<MerchantRankOvertimeDTO> merchantOvertimeRankDtos = await GetPaymentData(startDate, endDate, merchantId);
            //     return new VoucherConsumptionStatsResponse {
            //         ConsumedInPeriod = totalConsumed.TotalAmount,
            //         TransactionsInPeriod = totalConsumed.TransactionNumber,
            //         TotalTransactions = totalEverConsumed.TransactionNumber,
            //         TotalConsumed = totalEverConsumed.TotalAmount,
            //         MerchantOvertimeRanks = merchantOvertimeRankDtos,
            //         MerchantRanks = null,
            //         TotalConsumedOverTime = totalConsumedOverTimeDtos
            //     };
            // }
            // List<MerchantRankDTO> merchantRankDtos = await GetMerchantRank(startDate, endDate, merchantId);
            // return new VoucherConsumptionStatsResponse {
            //     ConsumedInPeriod = totalConsumed.TotalAmount,
            //     TransactionsInPeriod = totalConsumed.TransactionNumber,
            //     TotalTransactions = totalEverConsumed.TransactionNumber,
            //     TotalConsumed = totalEverConsumed.TotalAmount,
            //     MerchantRanks = merchantRankDtos,
            //     MerchantOvertimeRanks = null,
            //     TotalConsumedOverTime = totalConsumedOverTimeDtos
            // };
        }


        /// <summary>
        ///     Get total amount of vouchers consumed from all the merchants in a period of time
        /// </summary>
        public async Task<VouchersConsumedDTO> FetchTotalVouchersConsumed(
            DateTime? startDate,
            DateTime? endDate,
            ObjectId[] merchantsId
        ) {
            List<BsonDocument> pipeline = new List<BsonDocument>();
            // check if user is filtering for merchant name
            pipeline.AddRange(MongoQueryHelper.MerchantMatchFromPaymentRequestsCondition("merchantId", merchantsId));

            pipeline.Add(
                new BsonDocument("$unwind",
                    new BsonDocument {
                        { "path", "$confirmations" },
                        { "preserveNullAndEmptyArrays", true }
                    })
            );
            // check if user is filtering for date
            pipeline.Add(MongoQueryHelper.DateMatchCondition(startDate, endDate, "confirmations.performedAt"));

            pipeline.Add(
                new BsonDocument("$match",
                    new BsonDocument("confirmations",
                        new BsonDocument {
                            { "$exists", true }, {
                                "$ne",
                                new BsonArray()
                            }
                        }))
            );

            pipeline.Add(
                new BsonDocument("$group",
                    new BsonDocument {
                        { "_id", BsonNull.Value },
                        { "transactionNumber", new BsonDocument("$sum", 1) },
                        { "totalAmount", new BsonDocument("$sum", "$amount") }
                    })
            );

            IAsyncCursor<BsonDocument> result = await PaymentRequestCollection.AggregateAsync<BsonDocument>(pipeline);
            BsonDocument totalAmountConsumedDoc = await result.FirstOrDefaultAsync();

            // If no data was found
            if (totalAmountConsumedDoc == null) {
                return new VouchersConsumedDTO {
                    TransactionNumber = 0,
                    TotalAmount = 0
                };
            }

            return new VouchersConsumedDTO {
                TransactionNumber = totalAmountConsumedDoc.Contains("transactionNumber") ? totalAmountConsumedDoc["transactionNumber"].AsInt32 : 0,
                TotalAmount = totalAmountConsumedDoc.Contains("totalAmount") ? totalAmountConsumedDoc["totalAmount"].AsInt32 : 0
            };

        }


        /// <summary>
        ///     Get the consumed aim list from most used to least in a period of time
        /// </summary>
        public async Task<List<VoucherByAimDTO>> FetchTotalVouchersConsumedByAim(
            DateTime? startDate,
            DateTime? endDate,
            ObjectId[] merchantIds
        ) {
            List<BsonDocument> pipeline = new List<BsonDocument>();

            // Unwind confirmations array
            pipeline.Add(new BsonDocument("$unwind",
                new BsonDocument {
                    { "path", "$confirmations" },
                    { "preserveNullAndEmptyArrays", false }
                }));

            // check if user is filtering for merchant name
            pipeline.AddRange(MongoQueryHelper.MerchantMatchFromPaymentRequestsCondition("merchantId",merchantIds));

            // Project relevant fields
            pipeline.Add(
                new BsonDocument("$project",
                    new BsonDocument {
                        { "_id", 1 },
                        { "performedAt", "$confirmations.performedAt" },
                        { "posId", 1 },
                        { "amount", 1 }
                    }));

            // Match date range if provided
            if(startDate.HasValue && endDate.HasValue) {
                pipeline.Add(
                    new BsonDocument("$match",
                        new BsonDocument("confirmations.performedAt",
                            new BsonDocument {
                                {
                                    "$gte",
                                    startDate
                                }, {
                                    "$lte",
                                    endDate
                                }
                            }))
                );
            }

            // Group by aim and calculate total amount
            pipeline.Add(new BsonDocument("$group",
                new BsonDocument {
                    {
                        "_id",
                        new BsonDocument("aim",
                            new BsonDocument("$ifNull",
                                new BsonArray {
                                    "$filter.aims",
                                    "NoAim"
                                }))
                    }, {
                        "totalAmount",
                        new BsonDocument("$sum", "$amount")
                    }
                }));

            // Project final output
            pipeline.Add(new BsonDocument("$project",
                new BsonDocument {
                    { "_id", 0 },
                    { "aimCode", "$_id.aim" },
                    { "totalAmount", 1 }
                }));

            // Sort by total amount descending
            pipeline.Add(new BsonDocument("$sort",
                new BsonDocument("totalAmount", -1)));

            IAsyncCursor<BsonDocument> result = await PaymentRequestCollection.AggregateAsync<BsonDocument>(pipeline);
            List<BsonDocument> consumedVouchersByAim = await result.ToListAsync();

            // Map to a strongly-typed model
            List<VoucherByAimDTO> vouchersByAim = consumedVouchersByAim.Select(doc => new VoucherByAimDTO {
                AimCode = doc["aimCode"].AsString,
                Amount = doc["totalAmount"].AsInt32
            }).ToList();

            return vouchersByAim;
        }

        /// <summary>
        ///     Get merchant rank in a period of time
        /// </summary>
        public async Task<List<MerchantRankDTO>> GetMerchantRank(
            DateTime? startDate,
            DateTime? endDate,
            ObjectId[] merchantId
        ) {
            List<BsonDocument> pipeline = new List<BsonDocument>();

            pipeline.Add(
                new BsonDocument("$unwind",
                    new BsonDocument {
                        { "path", "$confirmations" },
                        { "preserveNullAndEmptyArrays", true }
                    })
            );
            // filter date if startDate and endDate not null
            pipeline.Add(
                MongoQueryHelper.DateMatchCondition(startDate, endDate, "confirmations.performedAt"));

            pipeline.Add(
                new BsonDocument("$lookup",
                    new BsonDocument {
                        { "from", "Merchants" },
                        { "localField", "merchantId" },
                        { "foreignField", "_id" },
                        { "as", "merchant" }
                    }));
            // group sum if filter date
            pipeline.Add(
                new BsonDocument("$group",
                    new BsonDocument {
                        { "_id", "$merchantId" }, {
                            "transactionNumber",
                            new BsonDocument("$sum", 1)
                        }, {
                            "totalAmount",
                            new BsonDocument("$sum", "$amount")
                        }, {
                            "name",
                            new BsonDocument("$first", "$merchant.name")
                        }
                    })
            );

            pipeline.Add(
                new BsonDocument("$project",
                    new BsonDocument {
                        { "_id", 1 }, {
                            "name",
                            new BsonDocument("$arrayElemAt",
                                new BsonArray {
                                    "$name",
                                    0
                                })
                        },
                        { "numberTransactions", 1 },
                        { "totalAmount", 1 }
                    }));

            pipeline.Add(
                new BsonDocument("$match",
                    new BsonDocument("name",
                        new BsonDocument("$ne", BsonNull.Value))));

            if(merchantId == null || merchantId.Length == 0) {
                pipeline.Add(
                    new BsonDocument(
                        "$unionWith",
                        new BsonDocument {
                            { "coll", "Merchants" }, {
                                "pipeline",
                                new BsonArray {
                                    new BsonDocument("$project",
                                        new BsonDocument {
                                            { "_id", "$_id" },
                                            { "name", "$name" }, {
                                                "totalAmount",
                                                new BsonDocument("$literal", 0)
                                            }
                                        })
                                }
                            }
                        }
                    )
                );
            }

            pipeline.Add(
                new BsonDocument("$group",
                    new BsonDocument {
                        { "_id", "$_id" }, {
                            "name",
                            new BsonDocument("$first", "$name")
                        }, {
                            "numberTransactions",
                            new BsonDocument("$first", "$numberTransactions")
                        }, {
                            "totalAmount",
                            new BsonDocument("$max", "$totalAmount")
                        }
                    })
            );

            pipeline.Add(
                new BsonDocument("$setWindowFields",
                    new BsonDocument {
                        {
                            "sortBy",
                            new BsonDocument("totalAmount", -1)
                        }, {
                            "output",
                            new BsonDocument("rank",
                                new BsonDocument("$denseRank",
                                    new BsonDocument()))
                        }
                    }));


            if(merchantId != null && merchantId.Length > 0) {
                pipeline.Add(
                    new BsonDocument("$match",
                        new BsonDocument("_id",
                            new BsonDocument("$in", new BsonArray(merchantId))
                        )
                    )
                );
            }

            try {
                Stopwatch stopwatch = Stopwatch.StartNew();
                IAsyncCursor<BsonDocument> result = await PaymentRequestCollection.AggregateAsync<BsonDocument>(pipeline);
                List<BsonDocument> merchantRankList = await result.ToListAsync();
                stopwatch.Stop();
                long elapsedMilliseconds = stopwatch.ElapsedMilliseconds;

                Logger.LogInformation($"Rank Aggregation pipeline executed in {elapsedMilliseconds} ms");

                // Map to a strongly-typed model
                List<MerchantRankDTO> merchantRank = merchantRankList.Select(doc => new MerchantRankDTO {
                    Id = doc["_id"].AsObjectId,
                    Name = doc["name"].AsString,
                    Amount = doc["totalAmount"].AsInt32,
                    NumberTransactions = doc.Contains("numberTransactions") && !doc["numberTransactions"].IsBsonNull
                        ? doc["numberTransactions"].AsInt32
                        : 0,
                    Rank = doc["rank"].AsInt32
                }).ToList();

                return merchantRank;
            }
            catch(Exception ex) {
                Console.WriteLine($"An error occurred: {ex.Message}");

                throw;
            }
        }

        public async Task<List<MerchantRankOvertimeDTO>> GetPaymentData(
            DateTime? startDate,
            DateTime? endDate,
            ObjectId[] merchantId) {
            List<BsonDocument> pipeline = new List<BsonDocument>();

            // Add confirmation field
            pipeline.Add(
                new BsonDocument("$addFields",
                    new BsonDocument("confirmation",
                        new BsonDocument("$arrayElemAt",
                            new BsonArray {
                                new BsonDocument("$map",
                                    new BsonDocument {
                                        { "input", "$confirmations" },
                                        { "as", "confirmation" },
                                        { "in", "$$confirmation.performedAt" }
                                    }),
                                0
                            })
                    )
                )
            );

            // Lookup Pos collection
            pipeline.Add(
                new BsonDocument("$lookup",
                    new BsonDocument {
                        { "from", "Pos" },
                        { "localField", "posId" },
                        { "foreignField", "_id" },
                        { "as", "posData" }
                    }
                )
            );

            // Add merchantId from Pos data
            pipeline.Add(
                new BsonDocument("$addFields",
                    new BsonDocument("merchantId",
                        new BsonDocument("$arrayElemAt",
                            new BsonArray {
                                "$posData.merchantId",
                                0
                            })
                    )
                )
            );

            // Lookup Merchants collection
            pipeline.Add(
                new BsonDocument("$lookup",
                    new BsonDocument {
                        { "from", "Merchants" },
                        { "localField", "merchantId" },
                        { "foreignField", "_id" },
                        { "as", "merchant" }
                    }
                )
            );

            // Add merchant name
            pipeline.Add(
                new BsonDocument("$addFields",
                    new BsonDocument("merchantName",
                        new BsonDocument("$arrayElemAt",
                            new BsonArray {
                                "$merchant.name",
                                0
                            })
                    )
                )
            );

            // Project specific fields
            pipeline.Add(
                new BsonDocument("$project",
                    new BsonDocument {
                        { "_id", 1 },
                        { "amount", 1 },
                        { "confirmation", 1 },
                        { "merchantId", 1 },
                        { "merchantName", 1 }
                    }
                )
            );

            // Execute pipeline
            List<BsonDocument> result = await PaymentRequestCollection.Aggregate<BsonDocument>(pipeline).ToListAsync();
            List<MerchantRankOvertimeDTO> overtimeRanks = result.Select(doc => new MerchantRankOvertimeDTO {
                Id = doc["_id"].IsObjectId ? doc["_id"].AsObjectId.ToString() : doc["_id"].AsBsonBinaryData.ToGuid().ToString(),
                Amount = doc.Contains("amount") ? doc["amount"].AsInt32 : 0,
                Date = doc.Contains("confirmation") && !doc["confirmation"].IsBsonNull
                    ? doc["confirmation"].ToUniversalTime().ToString("yyyy-MM-dd")
                    : null,
                MerchantId = doc.Contains("merchantId")
                    ? doc["merchantId"].IsObjectId ? doc["merchantId"].AsObjectId.ToString() : doc["merchantId"].AsString
                    : null,
                MerchantName = doc.Contains("merchantName") ? doc["merchantName"].AsString : null
            }).ToList();

            return overtimeRanks;
        }

        public async Task<List<TotalConsumedOverTimeDto>> GetTotalConsumedVouchersOverTime(
            DateTime? startDate,
            DateTime? endDate,
            ObjectId[]? merchantId,
            bool isDailyGranularity = false
        ) {
            List<BsonDocument> basePipeline = new List<BsonDocument>();

            // check if user is filtering for merchant name
            basePipeline.AddRange(MongoQueryHelper.MerchantMatchFromPaymentRequestsCondition("merchantId", merchantId));

            basePipeline.Add(new BsonDocument("$unwind",
                new BsonDocument {
                    { "path", "$confirmations" },
                    { "preserveNullAndEmptyArrays", true }
                })
            );

            basePipeline.Add(
                new BsonDocument("$addFields",
                    new BsonDocument("confirmations", "$confirmations.performedAt"))
            );

            string formatDate;

            // Add a date filter to the pipeline based on start and end dates, if provided
            basePipeline.Add(MongoQueryHelper.DateMatchCondition(startDate, endDate, "confirmations"));

            // Determine the date format for grouping or formatting output.
            // If a date range is provided and is not for the CSV, use the granularity derived from the range (e.g., daily or yearly).
            // Daily granularity for the CSVs
            // Otherwise, default to daily granularity for CSVs or yearly for dashboards.
            if(startDate.HasValue && endDate.HasValue) {
                formatDate = DateRangeHelper.GetDateFormatForRange(startDate.Value, endDate.Value, isDailyGranularity);
            }
            // CSV case
            else if(isDailyGranularity) {
                formatDate = "%Y-%m-%d";
            }
            else {
                formatDate = "%Y";
            }

            List<BsonDocument> dataPipeline = new List<BsonDocument>(basePipeline);
            dataPipeline.Add(
                new BsonDocument("$group",
                    new BsonDocument {
                        {
                            "_id",
                            new BsonDocument("$dateToString",
                                new BsonDocument {
                                    { "format", formatDate },
                                    { "date", "$confirmations" }
                                })
                        }, {
                            "totalAmount",
                            new BsonDocument("$sum", "$amount")
                        }
                    })
            );

            dataPipeline.Add(new BsonDocument("$sort",
                new BsonDocument("_id", 1))
            );

            IAsyncCursor<BsonDocument> result = PaymentRequestCollection.Aggregate<BsonDocument>(dataPipeline);
            List<BsonDocument> consumedOverTime = await result.ToListAsync();

            // transform format date from MongoDB to .NET
            string netFormatDate = formatDate.Replace("%Y", "yyyy").Replace("%m", "MM").Replace("%d", "dd");

            // Determine the increment unit based on the date format
            Func<DateTime, DateTime> incrementDate = DateRangeHelper.SetDateIncrement(netFormatDate);

            // Validate essential variables before calling the method
            if (PaymentRequestCollection == null) {
                throw new NullReferenceException("PaymentRequestCollection is null");
            }
            if (basePipeline == null) {
                throw new NullReferenceException("basePipeline is null");
            }
            if (incrementDate == null) {
                throw new NullReferenceException("incrementDate function is null");
            }

            List<string> allDates = MongoQueryHelper.GenerateDateRangeWithMissingData(
                startDate,
                endDate,
                "confirmations",
                netFormatDate,
                incrementDate,
                PaymentRequestCollection,
                basePipeline);

            // Map MongoDB results to DTO and create a dictionary by date
            Dictionary<string, TotalConsumedOverTimeDto> vouchersByAimDict = consumedOverTime
                .Where(doc => doc.Contains("_id") && doc["_id"].IsString)
                .ToDictionary(
                    doc => doc["_id"].AsString,
                    doc => new TotalConsumedOverTimeDto {
                        Date = doc["_id"].AsString,
                        Total = doc.Contains("totalAmount") && doc["totalAmount"].IsInt32 ? doc["totalAmount"].AsInt32 : 0
                    }
                );

            // Create the final list with missing dates filled with 0
            List<TotalConsumedOverTimeDto> vouchersByAim = allDates.Select(date => {
                if(vouchersByAimDict.ContainsKey(date)) {
                    return vouchersByAimDict[date];
                }

                return new TotalConsumedOverTimeDto {
                    Date = date,
                    Total = 0
                };
            }).ToList();

            return vouchersByAim;
        }
    }
}
